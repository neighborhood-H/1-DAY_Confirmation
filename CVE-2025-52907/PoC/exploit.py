#!/usr/bin/env python3
"""
safe_test.py

안전한 테스트 스크립트:
- 원래 PoC와 동일한 HTTP 요청 형식(헤더, JSON 본문)을 만들되
  *절대* 명령 삽입 문자열을 포함하지 않습니다.
- --simulate 옵션: 실제 요청을 보내지 않고, 단계별 시뮬레이션 출력만 함.
- 실제 전송 시에도 payload의 특정 문자(쉘 메타문자)를 검사하여 차단합니다.

사용법:
  python3 safe_test.py <target_ip> [--hostname HOSTNAME] [--simulate]
예:
  python3 safe_test.py 192.168.0.16 --hostname test9 --simulate
  python3 safe_test.py 192.168.0.16 --hostname lab-router
"""

import argparse
import json
import re
import requests
import sys
import time
from datetime import datetime

SHELL_METACHARS = re.compile(r"[;$`|&<>]")  # 단순 차단 규칙 (보수적)

def make_headers(target_ip: str):
    return {
        "Host": target_ip,
        "X-Requested-With": "XMLHttpRequest",
        "Accept-Language": "ko-KR,ko;q=0.9",
        "Accept": "application/json, text/javascript, */*; q=0.01",
        "Content-Type": "application/json; charset=UTF-8",
        "User-Agent": "SafeTest/1.0",
        "Origin": f"http://{target_ip}",
        "Referer": f"http://{target_ip}/wizard.html?token=",
        "Connection": "keep-alive",
    }

def safe_payload(hostname: str):
    # 절대적인 안전을 보장하진 않지만, 쉘 메타문자 포함 여부를 검사해서 차단함
    if SHELL_METACHARS.search(hostname):
        raise ValueError("호스트명에 쉘 메타문자가 포함되어 있어 전송을 차단했습니다.")
    return {
        "dhcpMtu": "1500",
        "proto": "1",
        "dnsMode": "0",
        "clone": "0",
        "cloneMac": "1C:F4:08:53:15:6D",
        "iptvEnabled": "0",
        "iptvVer": "5",
        "wanStrategy": "1",
        "vlanEnabled": "0",
        "ssid": "WiFi-2.4G",
        "key": "",
        "wifiOff": "1",
        "hssid": "0",
        "merge": "0",
        "ssid5g": "WiFi-5G",
        "key5g": "",
        "wifiOff5g": "1",
        "hssid5g": "0",
        "tz": "UTC+0",
        "loginpass": "admin",
        "step_index": "6",
        "wizard": "1",
        "topicurl": "setWizardCfg",   # 주의: 원래 취약 엔드포인트의 topicurl
        "hostName": hostname
    }

def pretty_print_request(url, headers, body):
    now = datetime.utcnow().isoformat() + "Z"
    print("=== REQUEST ===")
    print(f"Time: {now}")
    print(f"URL: {url}")
    print("Headers:")
    for k, v in headers.items():
        print(f"  {k}: {v}")
    print("JSON body:")
    print(json.dumps(body, indent=2, ensure_ascii=False))
    print("=== END REQUEST ===\n")

def pretty_print_response(resp):
    now = datetime.utcnow().isoformat() + "Z"
    print("=== RESPONSE ===")
    print(f"Time: {now}")
    print(f"Status: {resp.status_code}")
    print("Headers:")
    for k, v in resp.headers.items():
        print(f"  {k}: {v}")
    # 안전하게 프린트 (길이 제한)
    txt = resp.text
    print("Body (first 1000 chars):")
    print(txt[:1000])
    print("=== END RESPONSE ===\n")

def main():
    p = argparse.ArgumentParser(description="Safe HTTP tester for cstecgi.cgi (non-exploit)")
    p.add_argument("target_ip", help="Target router IP (e.g. 192.168.0.16)")
    p.add_argument("--hostname", default="test9", help="Safe hostName value (no shell meta chars)")
    p.add_argument("--simulate", action="store_true", help="Simulate only (do not send HTTP request)")
    p.add_argument("--timeout", type=int, default=10)
    args = p.parse_args()

    url = f"http://{args.target_ip}/cgi-bin/cstecgi.cgi"
    headers = make_headers(args.target_ip)
    body = safe_payload(args.hostname)

    pretty_print_request(url, headers, body)

    if args.simulate:
        print("[*] 시뮬레이션 모드: 실제 요청을 보내지 않습니다.")
        print("[*] 시뮬레이션 결과(예상 단계):")
        print("  1) 클라이언트가 JSON POST를 전송")
        print("  2) 웹 서버가 JSON을 파싱하고 topicurl에 따라 핸들러 호출")
        print("  3) setWizardCfg 핸들러가 안전한 입력이라면 UCI에 값 저장")
        print("  4) UCI 커밋 후 내부 로그에 'lan_change' 등 표시")
        print("  5) (실제 취약점이면) 악성 페이로드에 따라 추가 동작이 발생할 수 있음")
        sys.exit(0)

    print("[*] 실제 요청 전송 중...")
    try:
        start = time.time()
        resp = requests.post(url, headers=headers, data=json.dumps(body), timeout=args.timeout)
        elapsed = time.time() - start
        print(f"[*] 요청 전송 완료 (elapsed: {elapsed:.2f}s)\n")
        pretty_print_response(resp)
    except Exception as e:
        print(f"[!] 요청 중 예외 발생: {e}")

if __name__ == "__main__":
    main()